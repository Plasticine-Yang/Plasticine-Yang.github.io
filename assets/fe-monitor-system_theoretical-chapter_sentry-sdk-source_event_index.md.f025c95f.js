import{_ as e,c as t,o as n,a as o}from"./app.88074124.js";const m=JSON.parse('{"title":"Event","description":"","frontmatter":{},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"Event 的类型","slug":"event-的类型","link":"#event-的类型","children":[]}],"relativePath":"fe-monitor-system/theoretical-chapter/sentry-sdk-source/event/index.md","lastUpdated":1677082228000}'),a={name:"fe-monitor-system/theoretical-chapter/sentry-sdk-source/event/index.md"},c=o('<h1 id="event" tabindex="-1">Event <a class="header-anchor" href="#event" aria-hidden="true">#</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-hidden="true">#</a></h2><p>发往 Sentry 的数据都是先处理成 <code>Event</code>，然后再被处理成 <code>envelope</code> 发送出去</p><p>因此可以思考一下，<code>core</code> 包中的 client，作为底层应当提供以下几种能力：</p><ul><li><p>生成 Event</p><ul><li>根据 exception 生成 -- <code>eventFromException</code></li><li>根据 message 生成 -- <code>eventFromMessage</code></li></ul></li><li><p>发送 Event</p></li><li><p>捕获 exception -- 将 exception 转换成 event 并发送出去，可以复用 <code>eventFromException</code></p></li><li><p>捕获 message -- 将 message 转换成 event 并发送出去，可以复用 <code>eventFromMessage</code></p></li></ul><p>底层提供了这些能力后，browser 端的 client 就可以通过插件的方式去利用 event 集成额外信息，比如需要记录用户行为时，就可以将行为记录在 event 中，并通过 <code>breadcrumb</code> 插件来消费 event 生成用户行为信息进行记录</p><p>目前先明白底层提供的 event 相关的能力有哪些即可，接下来会逐个对照源码去分析</p><h2 id="event-的类型" tabindex="-1">Event 的类型 <a class="header-anchor" href="#event-的类型" aria-hidden="true">#</a></h2>',8),i=[c];function r(d,s,l,p,v,h){return n(),t("div",null,i)}const u=e(a,[["render",r]]);export{m as __pageData,u as default};
