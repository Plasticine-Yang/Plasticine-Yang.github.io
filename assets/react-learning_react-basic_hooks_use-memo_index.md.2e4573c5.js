import{_ as s,c as a,o as e,a as o}from"./app.9acfb210.js";const m=JSON.parse('{"title":"useMemo","description":"","frontmatter":{},"headers":[{"level":2,"title":"到底啥时候需要用 useMemo?","slug":"到底啥时候需要用-usememo","link":"#到底啥时候需要用-usememo","children":[]}],"relativePath":"react-learning/react-basic/hooks/use-memo/index.md","lastUpdated":1677473444000}'),n={name:"react-learning/react-basic/hooks/use-memo/index.md"},l=o(`<h1 id="usememo" tabindex="-1">useMemo <a class="header-anchor" href="#usememo" aria-hidden="true">#</a></h1><h2 id="到底啥时候需要用-usememo" tabindex="-1">到底啥时候需要用 useMemo? <a class="header-anchor" href="#到底啥时候需要用-usememo" aria-hidden="true">#</a></h2><p>一般用在 props 上，因为组件只要 props 变了就会 rerender，用 <code>useMemo</code> 可以避免不必要的 props 变化</p><p>比如：</p><div class="language-tsx"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">React</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">FC</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">memoizedValue</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useMemo</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">calcSomeValue</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">foo</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">bar</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> [</span><span style="color:#A6ACCD;">foo</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">bar</span><span style="color:#F07178;">])</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Bar</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">value</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">memoizedValue</span><span style="color:#89DDFF;">} /&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>如果不用 <code>useMemo</code> 包裹，那么每次 Foo 渲染， 即便 memoizedValue 依赖的 foo 和 bar 没变化，也会导致 memoizedValue 重新生成，其地址发生变化，导致 Bar 组件 rerender，但其实这是可以避免的</p>`,6),p=[l];function t(r,c,F,y,i,D){return e(),a("div",null,p)}const C=s(n,[["render",t]]);export{m as __pageData,C as default};
