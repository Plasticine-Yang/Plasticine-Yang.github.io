import{_ as a,c as e,o as s,a as l}from"./app.e2a0d70f.js";const t="/assets/ssr-progressive-hydration-islands对比.518a271e.png",f=JSON.parse('{"title":"介绍","description":"","frontmatter":{},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"islands 架构是什么？","slug":"islands-架构是什么","link":"#islands-架构是什么","children":[]},{"level":2,"title":"实现 islands 架构需要做哪些事？","slug":"实现-islands-架构需要做哪些事","link":"#实现-islands-架构需要做哪些事","children":[]},{"level":2,"title":"开发流程规划","slug":"开发流程规划","link":"#开发流程规划","children":[]},{"level":2,"title":"仓库管理方式","slug":"仓库管理方式","link":"#仓库管理方式","children":[]}],"relativePath":"project-actual-combat/plasticine-islands/introduction/index.md","lastUpdated":1677682543000}'),i={name:"project-actual-combat/plasticine-islands/introduction/index.md"},r=l('<h1 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-hidden="true">#</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-hidden="true">#</a></h2><p>本项目是对 <a href="https://www.patterns.dev/posts/islands-architecture/" target="_blank" rel="noreferrer">islands 架构</a> 的一个实现</p><p>仓库地址：<a href="https://github.com/Plasticine-Yang/plasticine-islands" target="_blank" rel="noreferrer">plasticine-islands</a></p><h2 id="islands-架构是什么" tabindex="-1">islands 架构是什么？ <a class="header-anchor" href="#islands-架构是什么" aria-hidden="true">#</a></h2><p>islands 架构支持在 SSR 场景下进行局部 <a href="/react-learning/react-basic/rendering/understanding-hydration/">hydration</a></p><p>传统的 SSR 渲染一个应用时，会进行全量渲染，也就是 <strong>生成整个页面的 html 字符串 + 整个页面的 hydration</strong></p><p>而在 islands 架构下，可以按照是否需要进行 hydration 将应用拆分成多个部分，也就是说这些部分包括：</p><ul><li>需要 hydrate 的部分</li><li>纯静态部分</li></ul><p>对于纯静态部分，直接在服务端生成 html 后返回即可，不需要进行 hydrate，而对于那些需要 hydrate 的部分，可以局部 hydrate，不需要像传统 SSR 那样全量 hydrate</p><p>这有别于渐进增强式地渲染，渐进增强渲染是 <strong>生成整个页面的 html 字符串 + 先 hydrate 重要部分，再逐渐 hydrate 其他部分</strong></p><p>下面这个图很好地对比了三种渲染方式的区别：</p><p><img src="'+t+`" alt="ssr-progressive-hydration-islands对比" data-fancybox="gallery"></p><h2 id="实现-islands-架构需要做哪些事" tabindex="-1">实现 islands 架构需要做哪些事？ <a class="header-anchor" href="#实现-islands-架构需要做哪些事" aria-hidden="true">#</a></h2><ol><li><p>在服务端需要支持零 JavaScript 完成页面的静态渲染</p></li><li><p>支持在静态内容通过 <code>placeholders</code> 嵌入独立的动态组件，每个动态组件都包含用于 hydrate 它自己的运行时代码，这些运行时代码最好是能够在 <code>requestIdleCallback</code> 这样的空闲时执行</p><p>就像这样：</p><div class="language-tsx"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Foo</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">__island</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"></span></code></pre></div><p>通过类似的方式将组件标记为动态组件，为它添加自己的 hydrate 运行时代码</p></li><li><p>支持同构渲染</p></li></ol><p>其实和 SSR 的能力很像，主要区别点就在于能够将应用按照组件划分为静态部分和支持自行 hydration 的部分</p><h2 id="开发流程规划" tabindex="-1">开发流程规划 <a class="header-anchor" href="#开发流程规划" aria-hidden="true">#</a></h2><p>本项目的开发流程如下：</p><ol><li>MVP 版本开发：在这个版本中主要实现传统的 SSR 同构渲染架构，为后续实现 islands 架构做铺垫</li><li>配置文件解析：会使用 <a href="https://github.com/antfu/unconfig" target="_blank" rel="noreferrer">unconfig</a> 实现</li><li>约定式路由：以 vite 插件的方式为我们的框架实现约定式路由特性</li><li>MDX 工具链集成：这块是框架的使用频率最高的部分 -- 支持解析 markdown, mdx 文件为 html 页面，并且会做一些 UI 上的抽象，使得能够像 <a href="https://vitepress.vuejs.org/" target="_blank" rel="noreferrer">vitepress</a> 那样通过配置的方式快速生成文档站点的 UI</li><li>主题 UI 的开发：基于 React 完成页面 UI 的开发</li><li>实现 islands 架构：本项目的重点和亮点</li><li>持续集成和部署：集成 CI/CD 能力，并发布 npm package</li></ol><h2 id="仓库管理方式" tabindex="-1">仓库管理方式 <a class="header-anchor" href="#仓库管理方式" aria-hidden="true">#</a></h2><p>由于项目涉及到 CLI、主题包、Core、vite 插件、babel 插件等多个模块，因此会采用 monorepo 的方式进行管理</p><p>采用的 monorepo 方案为 <a href="https://pnpm.io/workspaces" target="_blank" rel="noreferrer">pnpm workspace</a></p>`,22),n=[r];function d(o,p,c,h,_,g){return s(),e("div",null,n)}const m=a(i,[["render",d]]);export{f as __pageData,m as default};
