import{_ as e,c as i,o as l,a}from"./app.f289581c.js";const f=JSON.parse('{"title":"实现微前端的方案有哪些？","description":"","frontmatter":{},"headers":[{"level":2,"title":"方案概览","slug":"方案概览","link":"#方案概览","children":[]},{"level":2,"title":"按照是否「具备运行时动态化能力」划分","slug":"按照是否「具备运行时动态化能力」划分","link":"#按照是否「具备运行时动态化能力」划分","children":[]}],"relativePath":"micro-frontend/solutions/index.md","lastUpdated":1691234025000}'),t={name:"micro-frontend/solutions/index.md"},n=a('<h1 id="实现微前端的方案有哪些" tabindex="-1">实现微前端的方案有哪些？ <a class="header-anchor" href="#实现微前端的方案有哪些" aria-hidden="true">#</a></h1><h2 id="方案概览" tabindex="-1">方案概览 <a class="header-anchor" href="#方案概览" aria-hidden="true">#</a></h2><ul><li>基于 NPM 包的微前端：将微应用打包成独立的 NPM 包，然后在主应用中安装和使用；</li><li>基于代码分割的微前端：在主应用中使用懒加载技术，在运行时动态加载不同的微应用；</li><li>基于 Web Components 的微前端：将微应用封装成自定义组件，在主应用中注册使用；</li><li>基于 Module Federation 的微前端：借助 Webpack 5 的 Module Federation 实现微前端；</li><li>基于动态 Script 的微前端：在主应用中动态切换微应用的 Script 脚本来实现微前端；</li><li>基于 iframe 的微前端：在主应用中使用 iframe 标签来加载不同的微应用；</li><li>基于框架（JavaScript SDK）的微前端：使用 single-spa、qiankun、wujie 等通用框架。</li></ul><h2 id="按照是否「具备运行时动态化能力」划分" tabindex="-1">按照是否「具备运行时动态化能力」划分 <a class="header-anchor" href="#按照是否「具备运行时动态化能力」划分" aria-hidden="true">#</a></h2><p>所谓「运行时动态化能力」指的就是 <strong>主应用具备线上动态新增、删除和修改微应用的能力</strong></p><p>具备该能力的方案有：</p><ul><li>基于 NPM 包</li><li>基于代码分割</li><li>基于 Web Components</li><li>基于 Webpack 5 Module Federation</li></ul><p>这些方案都是在主应用构建时聚合微应用，因此在应用上线后无法动态调整微应用，需要等下一次发布新版本上线才能更新微应用</p><p>而具备该能力的方案有：</p><ul><li>基于动态 Script</li><li>基于 iframe</li><li>基于微前端框架</li></ul>',10),r=[n];function o(d,s,c,p,_,h){return l(),i("div",null,r)}const m=e(t,[["render",o]]);export{f as __pageData,m as default};
